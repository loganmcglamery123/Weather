<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vertical Profile</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #f0f2f5;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }

    .card {
      background: white;
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.1);
      width: 520px;
      text-align: center;
      position: relative;
    }

    h2 { margin: 0 0 6px 0; color: #333; font-size: 1.25rem; line-height: 1.25; }
    p  { color: #666; margin: 0 0 14px 0; font-size: 0.9rem; }

    .controls{
      display:flex; gap:10px; align-items:center; justify-content:center;
      margin: 0 0 14px 0;
      flex-wrap: wrap;
    }
    .controls label{ font-size:0.85rem; color:#444; font-weight:600; }
    .controls select, .controls input{
      padding:6px 8px; border:1px solid #ccc; border-radius:10px; background:#fff;
    }
    .controls button{
      padding:6px 10px; border:1px solid #bbb; border-radius:10px; background:#fff;
      font-weight:600; cursor:pointer;
    }

    /* Narrower chart */
    .chart-frame {
      position: relative;
      height: 600px;
      width: 18%;
      margin: 0 auto;
      border: 2px solid #333;
      background: #fafafa;
      margin-bottom: 20px;
    }

    .clipping-mask {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      overflow: hidden;
      z-index: 1;
    }

    .svg-layer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 20;
      pointer-events: none;
    }

    .y-axis-label {
      position: absolute;
      transform: rotate(-90deg);
      left: -90px;
      top: 50%;
      color: #555;
      font-weight: bold;
      font-size: 0.9rem;
      white-space: nowrap;
    }

    .wind-block {
      position: absolute;
      left: 0; width: 100%;
      border-top: 1px solid rgba(255,255,255,0.15);
      transition: opacity 0.2s;
    }

    /* Wind labels INSIDE chart, aligned right */
    .data-label {
      position: absolute;
      right: 6px;
      left: auto;
      width: auto;
      text-align: right;
      color: #111;
      font-weight: 900;
      text-shadow: 0 1px 2px rgba(255,255,255,0.6);
      font-size: 0.95rem;
      z-index: 30;
      pointer-events: none;
      transform: translateY(50%);
      white-space: nowrap;
    }

    .wind-arrow {
      display:inline-block;
      font-size: 1.25em;
      font-weight: 1000;
      line-height: 1;
      transform-origin: 50% 55%;
      filter: drop-shadow(0 1px 1px rgba(255,255,255,0.8));
      margin-left: 6px;
    }

    .alt-tick {
      position: absolute;
      left: -65px; width: 60px;
      text-align: right;
      font-size: 0.75rem; color: #666;
      transform: translateY(50%);
    }

    .grid-line {
      position: absolute;
      left: 0; width: 100%; height: 1px;
      border-top: 1px dashed #ddd;
    }

    /* Emoji label colors */
    .freezing-label { fill: #0066ff; font-size: 0.7rem; font-weight: bold; }
    .boundary-label { fill: #000;    font-size: 0.7rem; font-weight: bold; }
    .cloud-label    { fill: #555;    font-size: 0.7rem; font-weight: bold; }
    .elev-label     { fill: #2e7d32; font-size: 0.7rem; font-weight: bold; }
  </style>
</head>
<body>
  <div class="card">
    <h2 id="titleLine">Vertical Profile</h2>
    <p>Wind, Temp, Cloud Base & Boundary Layer</p>

    <div class="controls">
      <label for="modelSelect">Model:</label>
      <select id="modelSelect">
        <option value="">Best match (auto)</option>
        <option value="ecmwf_ifs">ECMWF IFS (HRES)</option>
        <option value="gfs_seamless">NCEP GFS (Seamless)</option>
        <option value="hrrr">HRRR (US only)</option>
        <option value="icon_seamless">DWD ICON (Seamless)</option>
        <option value="icon_global">DWD ICON (Global)</option>
        <option value="arpege_world">ARPEGE (World)</option>
        <option value="jma_seamless">JMA (Seamless)</option>
        <option value="custom">Customâ€¦</option>
      </select>

      <input id="customModel" type="text" placeholder="Enter Open-Meteo model id"
             style="display:none; width: 220px;" />

      <button id="reloadBtn" type="button">Load</button>
    </div>

    <div class="chart-frame" id="chartArea">
      <span class="y-axis-label">Altitude (ft)</span>
      <div class="clipping-mask" id="chartMask"></div>
      <svg class="svg-layer" id="svgLayer"></svg>
    </div>
  </div>

  <script>
    function getColor(speed) {
      const stops = [
        { s: 0,  c: [ 35,  75, 190] },
        { s: 5,  c: [ 45, 140, 220] },
        { s: 10, c: [ 80, 200, 255] },
        { s: 15, c: [ 60, 210, 140] },
        { s: 20, c: [ 40, 200,  60] },
        { s: 25, c: [180, 220,  40] },
        { s: 30, c: [255, 200,  40] },
        { s: 35, c: [255, 140,  40] },
        { s: 45, c: [235,  60,  60] },
        { s: 60, c: [190,  60, 170] },
        { s: 80, c: [140,  60, 220] }
      ];
      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const lerpColor = (c1, c2, t) => {
        const r = Math.round(lerp(c1[0], c2[0], t));
        const g = Math.round(lerp(c1[1], c2[1], t));
        const b = Math.round(lerp(c1[2], c2[2], t));
        return `rgb(${r},${g},${b})`;
      };

      const x = clamp(Number(speed) || 0, stops[0].s, stops[stops.length - 1].s);
      let i = 0;
      while (i < stops.length - 1 && x > stops[i + 1].s) i++;
      const a = stops[i];
      const b = stops[i + 1];
      const t = (x - a.s) / (b.s - a.s || 1);
      return lerpColor(a.c, b.c, t);
    }

    function getChosenModel() {
      const sel = document.getElementById("modelSelect");
      const custom = document.getElementById("customModel");
      const v = sel.value;
      if (v === "custom") return (custom.value || "").trim();
      return v;
    }

    function formatLatLon(lat, lon) {
      const f = (x) => (Math.round(x * 10000) / 10000).toFixed(4);
      return `${f(lat)}, ${f(lon)}`;
    }

    async function initChart(selectedModel = "") {
      const titleEl = document.getElementById("titleLine");
      const container = document.getElementById('chartArea');
      const mask = document.getElementById('chartMask');
      const svg = document.getElementById('svgLayer');

      const mToFt = 3.28084;

      const qs = new URLSearchParams(window.location.search);
      const lat = parseFloat(qs.get('lat'));
      const lon = parseFloat(qs.get('lon'));
      const altRaw = parseFloat(qs.get('alt'));
      const hasFix = Number.isFinite(lat) && Number.isFinite(lon);

      const currentElevationFt = Number.isFinite(altRaw) ? (altRaw * mToFt) : null;

      const levels = [1000, 975, 950, 925, 900, 875, 850, 825, 800, 775, 750, 725, 700, 675, 650, 625, 600, 575, 550, 525, 500];
      let hourlyParams = ["freezing_level_height", "boundary_layer_height", "temperature_2m", "dew_point_2m"];
      levels.forEach(l => {
        hourlyParams.push(`wind_speed_${l}hPa`, `wind_direction_${l}hPa`, `geopotential_height_${l}hPa`, `temperature_${l}hPa`);
      });

      const latitude = hasFix ? lat : 35.198;
      const longitude = hasFix ? lon : -111.651;

      const modelParam = selectedModel ? `&models=${encodeURIComponent(selectedModel)}` : "";

      const url =
        `https://api.open-meteo.com/v1/forecast` +
        `?latitude=${encodeURIComponent(latitude)}` +
        `&longitude=${encodeURIComponent(longitude)}` +
        `&hourly=${encodeURIComponent(hourlyParams.join(','))}` +
        `&timezone=auto&forecast_days=1` +
        `&wind_speed_unit=mph&temperature_unit=fahrenheit` +
        modelParam;

      try {
        const response = await fetch(url);
        const data = await response.json();

        if (data?.error) {
          console.error("Open-Meteo error:", data);
          alert(`Model/params error: ${data.reason || "unknown"}`);
          return;
        }

        const nowMs = Date.now();
        const timesMs = data.hourly.time.map(t => new Date(t).getTime());
        let tIndex = 0;
        let best = Infinity;
        for (let i = 0; i < timesMs.length; i++) {
          const d = Math.abs(timesMs[i] - nowMs);
          if (d < best) { best = d; tIndex = i; }
        }
        const forecastTimeStr = data.hourly.time[tIndex];

        const surfaceElevationFt = data.elevation * mToFt;

        const coordsStr = formatLatLon(latitude, longitude);
        const elevStr = `${Math.round(surfaceElevationFt)} ft`;
        titleEl.textContent = `Vertical Profile â€¢ ${coordsStr} â€¢ Elev ${elevStr} â€¢ ${forecastTimeStr}`;

        const freezingLevelFt = data.hourly.freezing_level_height[tIndex] * mToFt;
        const blHeightMSL = surfaceElevationFt + (data.hourly.boundary_layer_height[tIndex] * mToFt);

        const t2m = data.hourly.temperature_2m[tIndex];
        const dp2m = data.hourly.dew_point_2m[tIndex];
        const cloudBaseMSL = surfaceElevationFt + (((t2m - dp2m) / 4.4) * 1000);

        /* =============================
           Y-AXIS SCALING (NEW)
           Bottom: ground elevation
           Top: max( current alt, cloud base, boundary, freezing ) + 1000 ft
           ============================= */
        const topCandidate = Math.max(
          Number.isFinite(currentElevationFt) ? currentElevationFt : surfaceElevationFt,
          Number.isFinite(cloudBaseMSL) ? cloudBaseMSL : surfaceElevationFt,
          Number.isFinite(blHeightMSL) ? blHeightMSL : surfaceElevationFt,
          Number.isFinite(freezingLevelFt) ? freezingLevelFt : surfaceElevationFt
        );
        const chartTop = Math.ceil((topCandidate + 1000) / 1000) * 1000;

        let points = levels.map(level => {
          const s = data.hourly[`wind_speed_${level}hPa`][tIndex];
          const d = data.hourly[`wind_direction_${level}hPa`][tIndex];
          const a_gpm = data.hourly[`geopotential_height_${level}hPa`][tIndex];
          return { speed: s, dir: d, alt: a_gpm * mToFt };
        }).filter(p => p.speed !== null && p.alt !== null).sort((a, b) => a.alt - b.alt);

        mask.innerHTML = '';
        svg.innerHTML = '';
        container.querySelectorAll('.alt-tick, .grid-line, .data-label').forEach(el => el.remove());

        const viewHeight = chartTop - surfaceElevationFt;
        const getAltPct = (altFtMSL) => ((altFtMSL - surfaceElevationFt) / viewHeight) * 100;

        points.forEach((p, i) => {
          if (p.alt > chartTop + 1000) return;

          const nextAlt = points[i + 1] ? points[i + 1].alt : chartTop + 2000;
          const bottomPct = getAltPct(p.alt);
          const topPct = getAltPct(nextAlt);
          const heightPct = topPct - bottomPct;

          if (topPct < 0 || bottomPct > 100) return;

          const block = document.createElement('div');
          block.className = 'wind-block';
          block.style.bottom = `${bottomPct}%`;
          block.style.height = `${heightPct}%`;
          block.style.backgroundColor = getColor(p.speed);
          mask.appendChild(block);

          const vBottom = Math.max(bottomPct, 0);
          const vTop = Math.min(topPct, 100);
          if (vTop - vBottom > 3.0) {
            const center = vBottom + (vTop - vBottom) / 2;

            const label = document.createElement('div');
            label.className = 'data-label';
            label.style.bottom = `${center}%`;
            const toDirMet = (p.dir + 180) % 360;          // 0=N,90=E,180=S,270=W
            const rotDeg   = (toDirMet + 270) % 360;       // convert to CSS for âž¤ (0=E)
            label.innerHTML =
              `${Math.round(p.speed)} ` +
              `<span class="wind-arrow" style="transform:rotate(${rotDeg}deg)">âž¤</span>`;

          }
        });

        function drawEmojiMarker(altFtMSL, css, emoji, count, xPx = 6) {
          if (!Number.isFinite(altFtMSL)) return;
          const pct = getAltPct(altFtMSL);
          if (pct < 0 || pct > 100) return;

          const yPos = 100 - pct;

          const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
          t.setAttribute("x", `${xPx}px`);
          t.setAttribute("y", `${yPos}%`);
          t.setAttribute("class", css);
          t.setAttribute("dominant-baseline", "middle");
          t.style.fontSize = "18px";
          t.style.fontWeight = "900";
          t.textContent = emoji.repeat(Math.max(1, count));
          svg.appendChild(t);
        }

        drawEmojiMarker(freezingLevelFt, "freezing-label", "â„ï¸", 1);
        drawEmojiMarker(blHeightMSL, "boundary-label", "ðŸš€", 1);
        drawEmojiMarker(cloudBaseMSL, "cloud-label", "â˜ï¸", 1);
        if (Number.isFinite(currentElevationFt)) drawEmojiMarker(currentElevationFt, "elev-label", "ðŸª‚", 1);

        /* =============================
           TICKS (NEW)
           Include: ground, 1000s, and the four feature altitudes
           ============================= */
        const special = [
          surfaceElevationFt,
          Number.isFinite(currentElevationFt) ? currentElevationFt : null,
          Number.isFinite(cloudBaseMSL) ? cloudBaseMSL : null,
          Number.isFinite(blHeightMSL) ? blHeightMSL : null,
          Number.isFinite(freezingLevelFt) ? freezingLevelFt : null
        ].filter(v => Number.isFinite(v));

        // 1000-ft ticks from next 1000 above ground up to chartTop
        const ticks = new Set();
        ticks.add(Math.round(surfaceElevationFt));

        const startK = Math.ceil(surfaceElevationFt / 1000) * 1000;
        for (let a = startK; a <= chartTop; a += 1000) ticks.add(Math.round(a));

        // Add special altitudes (as exact ints)
        special.forEach(v => ticks.add(Math.round(v)));

        // Sorted tick list
        const tickVals = Array.from(ticks).sort((a, b) => a - b);

        tickVals.forEach(a => {
          const pct = getAltPct(a);
          if (pct < 0 || pct > 100) return;

          const tick = document.createElement('div');
          tick.className = 'alt-tick';
          tick.style.bottom = `${pct}%`;
          tick.innerText = a;

          const grid = document.createElement('div');
          grid.className = 'grid-line';
          grid.style.bottom = `${pct}%`;

          container.appendChild(tick);
          container.appendChild(grid);
        });
      } catch (e) {
        console.error(e);
      }
    }

    const modelSelect = document.getElementById("modelSelect");
    const customModel = document.getElementById("customModel");
    const reloadBtn = document.getElementById("reloadBtn");

    const saved = localStorage.getItem("openmeteo_model") || "";
    if (saved) {
      const opts = Array.from(modelSelect.options).map(o => o.value);
      if (opts.includes(saved)) {
        modelSelect.value = saved;
      } else {
        modelSelect.value = "custom";
        customModel.style.display = "inline-block";
        customModel.value = saved;
      }
    }

    modelSelect.addEventListener("change", () => {
      customModel.style.display = (modelSelect.value === "custom") ? "inline-block" : "none";
    });

    reloadBtn.addEventListener("click", () => {
      const chosen = getChosenModel();
      localStorage.setItem("openmeteo_model", chosen);
      initChart(chosen);
    });

    initChart(getChosenModel());
  </script>
</body>
</html>
