<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vertical Profile</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #f0f2f5;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }

    .card {
      background: white;
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.1);
      width: 520px;
      text-align: center;
      position: relative;
    }

    h2 { margin: 0 0 6px 0; color: #333; font-size: 1.25rem; line-height: 1.25; }
    p  { color: #666; margin: 0 0 14px 0; font-size: 0.9rem; }

    .controls{
      display:flex; gap:10px; align-items:center; justify-content:center;
      margin: 0 0 14px 0;
      flex-wrap: wrap;
    }
    .controls label{ font-size:0.85rem; color:#444; font-weight:600; }
    .controls select, .controls input{
      padding:6px 8px; border:1px solid #ccc; border-radius:10px; background:#fff;
    }
    .controls button{
      padding:6px 10px; border:1px solid #bbb; border-radius:10px; background:#fff;
      font-weight:600; cursor:pointer;
    }

    .chart-frame {
      position: relative;
      height: 600px;
      width: 60%;
      margin: 0 auto;
      border: 2px solid #333;
      background: #fafafa;
      margin-bottom: 20px;
    }

    .clipping-mask {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      overflow: hidden;
      z-index: 1;
    }

    .svg-layer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 20;
      pointer-events: none;
    }

    .y-axis-label {
      position: absolute;
      transform: rotate(-90deg);
      left: -90px;
      top: 50%;
      color: #555;
      font-weight: bold;
      font-size: 0.9rem;
      white-space: nowrap;
    }

    .wind-block {
      position: absolute;
      left: 0; width: 100%;
      border-top: 1px solid rgba(255,255,255,0.15);
      transition: opacity 0.2s;
    }

    .data-label {
      position: absolute;
      left: 0; width: 100%;
      text-align: center;
      color: white;
      font-weight: 900;
      text-shadow: 0 1px 2px rgba(0,0,0,0.45);
      font-size: 1.05rem;
      z-index: 5;
      pointer-events: none;
      transform: translateY(50%);
      letter-spacing: 0.2px;
    }

    /* Bigger/bolder arrow */
    .wind-arrow {
      display:inline-block;
      font-size: 1.35em;
      font-weight: 1000;
      line-height: 1;
      transform-origin: 50% 55%;
      filter: drop-shadow(0 1px 1px rgba(0,0,0,0.4));
      margin-left: 6px;
    }

    .alt-tick {
      position: absolute;
      left: -65px; width: 60px;
      text-align: right;
      font-size: 0.75rem; color: #666;
      transform: translateY(50%);
    }

    .temp-tick {
      position: absolute;
      right: -60px; width: 50px;
      text-align: left;
      font-size: 0.8rem; font-weight: bold; color: #d32f2f;
      transform: translateY(50%);
    }

    .grid-line {
      position: absolute;
      left: 0; width: 100%; height: 1px;
      border-top: 1px dashed #ddd;
    }

    /* LINE STYLES */
    .freezing-line { stroke: #0066ff; stroke-width: 2; stroke-dasharray: 6,4; }
    .freezing-label { fill: #0066ff; font-size: 0.7rem; font-weight: bold; }

    .boundary-line { stroke: #000; stroke-width: 2; }
    .boundary-label { fill: #000; font-size: 0.7rem; font-weight: bold; }

    .cloud-line { stroke: #777; stroke-width: 2; stroke-dasharray: 3,3; }
    .cloud-label { fill: #555; font-size: 0.7rem; font-weight: bold; }

    .elev-line { stroke: #2e7d32; stroke-width: 2; stroke-dasharray: 2,4; }
    .elev-label { fill: #2e7d32; font-size: 0.7rem; font-weight: bold; }

    .temp-header {
      position: absolute;
      right: -70px; top: -25px;
      font-size: 0.8rem; font-weight: bold; color: #d32f2f;
    }
  </style>
</head>
<body>
  <div class="card">
    <h2 id="titleLine">Vertical Profile</h2>
    <p>Wind, Temp, Cloud Base & Boundary Layer</p>

    <div class="controls">
      <label for="modelSelect">Model:</label>
      <select id="modelSelect">
        <option value="">Best match (auto)</option>
        <option value="ecmwf_ifs">ECMWF IFS (HRES)</option>
        <option value="gfs_seamless">NCEP GFS (Seamless)</option>
        <option value="hrrr">HRRR (US only)</option>
        <option value="icon_seamless">DWD ICON (Seamless)</option>
        <option value="icon_global">DWD ICON (Global)</option>
        <option value="arpege_world">ARPEGE (World)</option>
        <option value="jma_seamless">JMA (Seamless)</option>
        <option value="custom">Custom‚Ä¶</option>
      </select>

      <input id="customModel" type="text" placeholder="Enter Open-Meteo model id"
             style="display:none; width: 220px;" />

      <button id="reloadBtn" type="button">Load</button>
    </div>

    <div class="chart-frame" id="chartArea">
      <span class="y-axis-label">Altitude (ft)</span>
      <span class="temp-header">Temp (¬∞F)</span>
      <div class="clipping-mask" id="chartMask"></div>
      <svg class="svg-layer" id="svgLayer"></svg>
    </div>
  </div>

  <script>
    // ----------------------------
    // Windy-ish continuous ramp
    // ----------------------------
    function getColor(speed) {
      const stops = [
        { s: 0,  c: [ 35,  75, 190] },
        { s: 5,  c: [ 45, 140, 220] },
        { s: 10, c: [ 80, 200, 255] },
        { s: 15, c: [ 60, 210, 140] },
        { s: 20, c: [ 40, 200,  60] },
        { s: 25, c: [180, 220,  40] },
        { s: 30, c: [255, 200,  40] },
        { s: 35, c: [255, 140,  40] },
        { s: 45, c: [235,  60,  60] },
        { s: 60, c: [190,  60, 170] },
        { s: 80, c: [140,  60, 220] }
      ];

      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const lerpColor = (c1, c2, t) => {
        const r = Math.round(lerp(c1[0], c2[0], t));
        const g = Math.round(lerp(c1[1], c2[1], t));
        const b = Math.round(lerp(c1[2], c2[2], t));
        return `rgb(${r},${g},${b})`;
      };

      const x = clamp(Number(speed) || 0, stops[0].s, stops[stops.length - 1].s);
      let i = 0;
      while (i < stops.length - 1 && x > stops[i + 1].s) i++;
      const a = stops[i];
      const b = stops[i + 1];
      const t = (x - a.s) / (b.s - a.s || 1);
      return lerpColor(a.c, b.c, t);
    }

    function getChosenModel() {
      const sel = document.getElementById("modelSelect");
      const custom = document.getElementById("customModel");
      const v = sel.value;
      if (v === "custom") return (custom.value || "").trim();
      return v; // "" means auto
    }

    function formatLatLon(lat, lon) {
      const f = (x) => (Math.round(x * 10000) / 10000).toFixed(4);
      return `${f(lat)}, ${f(lon)}`;
    }

    async function initChart(selectedModel = "") {
      const titleEl = document.getElementById("titleLine");
      const container = document.getElementById('chartArea');
      const mask = document.getElementById('chartMask');
      const svg = document.getElementById('svgLayer');

      const mToFt = 3.28084;

      // ---- read coords/alt from query string (XCTrack passes these)
      const qs = new URLSearchParams(window.location.search);
      const lat = parseFloat(qs.get('lat'));
      const lon = parseFloat(qs.get('lon'));
      const altRaw = parseFloat(qs.get('alt')); // meters (XCTrack)
      const hasFix = Number.isFinite(lat) && Number.isFinite(lon);

      // Current Elevation (ft MSL) from XCTrack-provided alt
      const currentElevationFt = Number.isFinite(altRaw) ? (altRaw * mToFt) : null;

      const levels = [1000, 975, 950, 925, 900, 875, 850, 825, 800, 775, 750, 725, 700, 675, 650, 625, 600, 575, 550, 525, 500];
      let hourlyParams = ["freezing_level_height", "boundary_layer_height", "temperature_2m", "dew_point_2m"];
      levels.forEach(l => {
        hourlyParams.push(`wind_speed_${l}hPa`, `wind_direction_${l}hPa`, `geopotential_height_${l}hPa`, `temperature_${l}hPa`);
      });

      const latitude = hasFix ? lat : 35.198;
      const longitude = hasFix ? lon : -111.651;

      const modelParam = selectedModel ? `&models=${encodeURIComponent(selectedModel)}` : "";

      const url =
        `https://api.open-meteo.com/v1/forecast` +
        `?latitude=${encodeURIComponent(latitude)}` +
        `&longitude=${encodeURIComponent(longitude)}` +
        `&hourly=${encodeURIComponent(hourlyParams.join(','))}` +
        `&timezone=auto&forecast_days=1` +
        `&wind_speed_unit=mph&temperature_unit=fahrenheit` +
        modelParam;

      try {
        const response = await fetch(url);
        const data = await response.json();

        if (data?.error) {
          console.error("Open-Meteo error:", data);
          alert(`Model/params error: ${data.reason || "unknown"}`);
          return;
        }

        // ---- FIXED TIME INDEX: choose nearest forecast hour to now using epoch ms
        const nowMs = Date.now();
        const timesMs = data.hourly.time.map(t => new Date(t).getTime());
        let tIndex = 0;
        let best = Infinity;
        for (let i = 0; i < timesMs.length; i++) {
          const d = Math.abs(timesMs[i] - nowMs);
          if (d < best) { best = d; tIndex = i; }
        }
        const forecastTimeStr = data.hourly.time[tIndex]; // local time string (timezone=auto)

        const surfaceElevationFt = data.elevation * mToFt;
        const chartTop = 18000;

        // ---- Title: coordinates, elevation, forecast time
        const coordsStr = formatLatLon(latitude, longitude);
        const elevStr = `${Math.round(surfaceElevationFt)} ft`;
        titleEl.textContent = `Vertical Profile ‚Ä¢ ${coordsStr} ‚Ä¢ Elev ${elevStr} ‚Ä¢ ${forecastTimeStr}`;

        const freezingLevelFt = data.hourly.freezing_level_height[tIndex] * mToFt; // ft MSL
        const blHeightMSL = surfaceElevationFt + (data.hourly.boundary_layer_height[tIndex] * mToFt); // ft MSL

        const t2m = data.hourly.temperature_2m[tIndex];
        const dp2m = data.hourly.dew_point_2m[tIndex];
        const cloudBaseMSL = surfaceElevationFt + (((t2m - dp2m) / 4.4) * 1000); // ft MSL

        let points = levels.map(level => {
          const s = data.hourly[`wind_speed_${level}hPa`][tIndex];
          const d = data.hourly[`wind_direction_${level}hPa`][tIndex];
          const a_gpm = data.hourly[`geopotential_height_${level}hPa`][tIndex]; // geopotential meters (gpm), unit "m"
          const t = data.hourly[`temperature_${level}hPa`][tIndex];
          return { speed: s, dir: d, alt: a_gpm * mToFt, temp: t };
        }).filter(p => p.speed !== null && p.alt !== null).sort((a, b) => a.alt - b.alt);

        // Clear layers
        mask.innerHTML = '';
        svg.innerHTML = '';
        container.querySelectorAll('.alt-tick, .temp-tick, .grid-line, .data-label').forEach(el => el.remove());

        const viewHeight = chartTop - surfaceElevationFt;
        const getAltPct = (altFtMSL) => ((altFtMSL - surfaceElevationFt) / viewHeight) * 100;

        points.forEach((p, i) => {
          if (p.alt > chartTop + 1000) return;

          const nextAlt = points[i + 1] ? points[i + 1].alt : chartTop + 2000;
          const bottomPct = getAltPct(p.alt);
          const topPct = getAltPct(nextAlt);
          const heightPct = topPct - bottomPct;

          if (topPct < 0 || bottomPct > 100) return;

          const block = document.createElement('div');
          block.className = 'wind-block';
          block.style.bottom = `${bottomPct}%`;
          block.style.height = `${heightPct}%`;
          block.style.backgroundColor = getColor(p.speed);
          mask.appendChild(block);

          const vBottom = Math.max(bottomPct, 0);
          const vTop = Math.min(topPct, 100);
          if (vTop - vBottom > 3.0) {
            const center = vBottom + (vTop - vBottom) / 2;

            const label = document.createElement('div');
            label.className = 'data-label';
            label.style.bottom = `${center}%`;
            label.innerHTML =
              `${Math.round(p.speed)} ` +
              `<span class="wind-arrow" style="transform:rotate(${p.dir}deg)">‚Üì</span>`;
            container.appendChild(label);

            const tTick = document.createElement('div');
            tTick.className = 'temp-tick';
            tTick.style.bottom = `${center}%`;
            tTick.innerText = Math.round(p.temp) + '¬∞';
            container.appendChild(tTick);
          }
        });

        // Add icons to line labels (emoji are simplest + work offline)
        // Emoji-only marker (no horizontal line)
        function drawEmojiMarker(altFtMSL, css, emoji, count, showAltFt, xPx = 6) {
          if (!Number.isFinite(altFtMSL)) return;
          const pct = getAltPct(altFtMSL);
          if (pct < 0 || pct > 100) return;
        
          const yPos = 100 - pct;
        
          const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
          t.setAttribute("x", `${xPx}px`);
          t.setAttribute("y", `${yPos}%`);
          t.setAttribute("class", css);           // reuse your existing label colors if you want
          t.setAttribute("dominant-baseline", "middle");
        
          // Make emojis bigger here:
          t.style.fontSize = "18px";              // <-- increase/decrease
          t.style.fontWeight = "900";
        
          const emojiStr = count > 1 ? emoji.repeat(count) : emoji;
          const altStr = showAltFt ? ` (${Math.round(altFtMSL)}ft)` : "";
          t.textContent = `${emojiStr}${altStr}`;
        
          svg.appendChild(t);
        }
        
        // Replace your old drawLine calls with these:
        drawEmojiMarker(freezingLevelFt, "freezing-label", "‚ùÑÔ∏è", 3, true);
        drawEmojiMarker(blHeightMSL, "boundary-label", "üöÄ", 3, true);
        drawEmojiMarker(cloudBaseMSL, "cloud-label", "‚òÅÔ∏è", 3, true);
        
        // Current elev: single paraglider + alt
        if (Number.isFinite(currentElevationFt)) {
          drawEmojiMarker(currentElevationFt, "elev-label", "ü™Ç", 1, true);
        }


        // Ticks
        for (let a = Math.ceil(surfaceElevationFt / 1000) * 1000; a <= chartTop; a += 1000) {
          const pct = getAltPct(a);
          if (pct < 3.5) continue;

          const tick = document.createElement('div');
          tick.className = 'alt-tick';
          tick.style.bottom = `${pct}%`;
          tick.innerText = Math.round(a);

          const grid = document.createElement('div');
          grid.className = 'grid-line';
          grid.style.bottom = `${pct}%`;

          container.appendChild(tick);
          container.appendChild(grid);
        }
      } catch (e) {
        console.error(e);
      }
    }

    // Controls wiring + persistence
    const modelSelect = document.getElementById("modelSelect");
    const customModel = document.getElementById("customModel");
    const reloadBtn = document.getElementById("reloadBtn");

    // restore previous
    const saved = localStorage.getItem("openmeteo_model") || "";
    if (saved) {
      const opts = Array.from(modelSelect.options).map(o => o.value);
      if (opts.includes(saved)) {
        modelSelect.value = saved;
      } else {
        modelSelect.value = "custom";
        customModel.style.display = "inline-block";
        customModel.value = saved;
      }
    }

    modelSelect.addEventListener("change", () => {
      customModel.style.display = (modelSelect.value === "custom") ? "inline-block" : "none";
    });

    reloadBtn.addEventListener("click", () => {
      const chosen = getChosenModel();
      localStorage.setItem("openmeteo_model", chosen);
      initChart(chosen);
    });

    // initial load
    initChart(getChosenModel());
  </script>
</body>
</html>
